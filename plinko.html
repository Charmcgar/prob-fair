<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Plinko Game: Camera Tracking + Auto Delete Balls</title>
<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
<style>
  body {
    margin:0; background:#000; color:#ccc; font-family: monospace;
    overflow:hidden;
  }
  #container {
    position: relative;
    width: 600px;
    height: 900px;
    margin: auto;
    overflow: hidden;
    border-radius: 12px;
    box-shadow: 0 0 15px #3b82f6;
  }
  canvas {
    display: block;
    background:#0a0a0a;
  }
  #graph, #info {
    position: fixed; bottom:0; width:250px; background:#222; border-radius:12px 12px 0 0; padding:10px;
    box-sizing:border-box; font-size:14px;
  }
  #graph { left:0; border-top:3px solid #3b82f6; }
  #info { right:0; border-top:3px solid #3b82f6; text-align:center; }
  #graphBars {
    display:flex; justify-content:space-between; align-items:flex-end; height:120px; margin-top:10px;
  }
  .bar {
    width:14%; background: linear-gradient(to top, #3b82f6, #1e40af);
    border-radius:6px 6px 0 0; box-shadow:0 0 10px #3b82f6;
    display:flex; justify-content:center; align-items:flex-end; color:#fff; font-weight:700; position:relative;
    transition: height 0.4s ease;
  }
  .count {
    position:absolute; top:-20px; color:#3b82f6; font-variant-numeric:tabular-nums;
  }
  #instructions {
    position: fixed; top:10px; left:10px; background:rgba(0,0,0,0.75); padding:10px; border-radius:8px; font-size:14px;
    box-shadow:0 0 10px #3b82f6; user-select:none;
  }
</style>
</head>
<body>

<div id="container">
  <canvas id="canvas" width="600" height="900"></canvas>
</div>

<div id="graph">
  <div>Slot Distribution</div>
  <div id="graphBars"></div>
</div>
<div id="info">
  <div><strong>Total Balls:</strong> <span id="totalBalls">0</span></div>
  <div><strong>Top Slot:</strong> <span id="topSlot">N/A</span></div>
</div>
<div id="instructions">
  Press <b>Space</b> to drop one ball.<br>
  Press <b>1</b> to drop 100 balls.
</div>

<script>
(() => {
  const { Engine, Render, Runner, Bodies, World, Events, Body } = Matter;
  const W = 600, H = 900;
  const engine = Engine.create(), world = engine.world;

  const canvas = document.getElementById('canvas');
  const render = Render.create({
    canvas,
    engine,
    options: {
      width: W,
      height: H,
      wireframes: false,
      background: 'transparent',
      hasBounds: true
    }
  });

  Render.run(render);
  Runner.run(Runner.create(), engine);

  // Graph setup
  const slots = 6;
  let slotCounts = Array(slots).fill(0), totalBalls = 0;
  const barsContainer = document.getElementById('graphBars');
  const bars = [];
  for (let i = 0; i < slots; i++) {
    const bar = document.createElement('div');
    bar.className = 'bar';
    bar.style.height = '0%';
    const count = document.createElement('span');
    count.className = 'count';
    count.textContent = '0';
    bar.appendChild(count);
    barsContainer.appendChild(bar);
    bars.push({ bar, count });
  }
  const totalBallsSpan = document.getElementById('totalBalls');
  const topSlotSpan = document.getElementById('topSlot');

  // Walls
  World.add(world, [
    Bodies.rectangle(W / 2, 0, W, 50, { isStatic: true }),
    Bodies.rectangle(W / 2, H, W, 50, { isStatic: true }),
    Bodies.rectangle(0, H / 2, 50, H, { isStatic: true }),
    Bodies.rectangle(W, H / 2, 50, H, { isStatic: true }),
  ]);

  // Pegs (static, no movement)
  const rows = 10, cols = 11, spacing = 60;
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const offset = r % 2 ? 0 : spacing / 2;
      const x = c * spacing + offset + 30;
      const y = r * spacing + 120;
      const peg = Bodies.circle(x, y, 8, {
        isStatic: true,
        render: { fillStyle: '#1e40af', strokeStyle: '#3b82f6', lineWidth: 3 }
      });
      World.add(world, peg);
    }
  }

  // Slot dividers + floor
  for (let i = 0; i <= slots; i++) {
    World.add(world, Bodies.rectangle(i * W / slots, H - 90, 10, 180, {
      isStatic: true,
      render: { fillStyle: '#222' }
    }));
  }
  const floor = Bodies.rectangle(W / 2, H - 20, W, 40, {
    isStatic: true,
    render: { fillStyle: '#111' },
    label: 'floor'
  });
  World.add(world, floor);

  // Particle system (lightweight)
  const ctx = render.context;
  const particles = [];
  function addParticle(x, y, color) {
    if (particles.length > 60) return; // limit particles for perf
    particles.push({
      x, y,
      r: Math.random() * 2 + 1,
      alpha: 1,
      color,
      vx: (Math.random() - 0.5) * 0.5,
      vy: (Math.random() - 1) * 0.5,
      life: 40
    });
  }
  function drawParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      ctx.beginPath();
      ctx.fillStyle = `rgba(${p.color.r},${p.color.g},${p.color.b},${p.alpha})`;
      ctx.shadowColor = `rgba(${p.color.r},${p.color.g},${p.color.b},${p.alpha})`;
      ctx.shadowBlur = 8;
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
      p.x += p.vx;
      p.y += p.vy;
      p.alpha -= 0.03;
      p.life--;
      if (p.life <= 0 || p.alpha <= 0) particles.splice(i, 1);
    }
  }

  // Balls array
  let balls = [];

  // Convert hsl string "hsl(h,s%,l%)" to rgb object for particles
  function hslToRgb(hsl) {
    let [h, s, l] = hsl.match(/(\d+\.?\d*)/g).map(Number);
    s /= 100; l /= 100;
    let c = (1 - Math.abs(2 * l - 1)) * s;
    let x = c * (1 - Math.abs((h / 60) % 2 - 1));
    let m = l - c / 2;
    let r = 0, g = 0, b = 0;
    if (h < 60) { r = c; g = x; b = 0; }
    else if (h < 120) { r = x; g = c; b = 0; }
    else if (h < 180) { r = 0; g = c; b = x; }
    else if (h < 240) { r = 0; g = x; b = c; }
    else if (h < 300) { r = x; g = 0; b = c; }
    else { r = c; g = 0; b = x; }
    return { r: Math.round((r + m) * 255), g: Math.round((g + m) * 255), b: Math.round((b + m) * 255) };
  }

  // Drop ball at fully random X spawn location (within board bounds)
  function dropBall() {
    const x = Math.random() * (W - 60) + 30;
    const ball = Bodies.circle(x, 50, 12, {
      restitution: 0.5,
      render: { fillStyle: `hsl(${Math.random() * 360},100%,50%)` }
    });
    ball.trailColor = hslToRgb(ball.render.fillStyle);
    balls.push(ball);
    World.add(world, ball);
    latestBall = ball; // For camera tracking
  }

  // Camera tracking variables
  let latestBall = null;

  // Update ball particles & remove balls that touch floor
  Events.on(engine, 'afterUpdate', () => {
    balls.forEach(ball => {
      addParticle(ball.position.x, ball.position.y, ball.trailColor);
    });

    // Remove balls that touched or passed the floor
    balls = balls.filter(ball => {
      if (ball.position.y > H - 60) {
        World.remove(world, ball);
        return false;
      }
      return true;
    });

    drawParticles();

    // Camera tracking
    if (latestBall) {
      let { x, y } = latestBall.position;
      const halfW = W / 2;
      const halfH = H / 2;
      // Clamp camera so it doesn't show out of bounds
      x = Math.min(W - halfW, Math.max(halfW, x));
      y = Math.min(H - halfH, Math.max(halfH, y));
      render.bounds.min.x = x - halfW;
      render.bounds.max.x = x + halfW;
      render.bounds.min.y = y - halfH;
      render.bounds.max.y = y + halfH;
    }
  });

  // Update stats on collision with floor (only count ball once)
  Events.on(engine, 'collisionStart', e => {
    e.pairs.forEach(({ bodyA, bodyB }) => {
      const ball = [bodyA, bodyB].find(b => !b.isStatic);
      const floorHit = [bodyA, bodyB].find(b => b.label === 'floor');
      if (ball && floorHit && !ball.counted) {
        const idx = Math.min(slots - 1, Math.floor(ball.position.x / (W / slots)));
        slotCounts[idx]++;
        totalBalls++;
        ball.counted = true;
        totalBallsSpan.textContent = totalBalls;
        const maxCount = Math.max(...slotCounts);
        const topIdx = slotCounts.indexOf(maxCount);
        topSlotSpan.textContent = topIdx + 1;

        for (let i = 0; i < 15; i++) addParticle(ball.position.x, H - 60, ball.trailColor);
        updateGraph();
      }
    });
  });

  function updateGraph() {
    const max = Math.max(...slotCounts, 1);
    bars.forEach(({ bar, count }, i) => {
      const h = (slotCounts[i] / max) * 100;
      bar.style.height = h + '%';
      count.textContent = slotCounts[i];
    });
  }

  // Controls
  window.addEventListener('keydown', e => {
    if (e.code === 'Space') dropBall();
    else if (e.key === '1') {
      for (let i = 0; i < 100; i++) setTimeout(dropBall, i * 30);
    }
  });

  updateGraph();
})();
</script>

</body>
</html>
