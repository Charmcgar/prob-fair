<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>2D Virtual Wind Tunnel - WebGL Fluid Simulation</title>
<style>
  body, html { margin:0; padding:0; overflow:hidden; background:#111; }
  canvas { display:block; image-rendering: pixelated; }
  #info {
    position: absolute; top: 10px; left: 10px; color: #eee; font-family: monospace;
    background: rgba(0,0,0,0.4); padding: 8px; border-radius: 6px;
  }
</style>
</head>
<body>
<div id="info">
  Click to add/remove obstacles (white squares).<br/>
  Wind flows from left to right.<br/>
  Red = High pressure, Blue = Low pressure.
</div>
<canvas id="canvas"></canvas>
<script id="vertexShader" type="x-shader/x-vertex">
precision mediump float;
attribute vec2 a_position;
varying vec2 v_uv;
void main() {
  v_uv = a_position * 0.5 + 0.5;
  gl_Position = vec4(a_position, 0, 1);
}
</script>
<script id="fragmentShaderAdvect" type="x-shader/x-fragment">
precision highp float;
varying vec2 v_uv;
uniform sampler2D u_velocity;
uniform sampler2D u_source;
uniform float dt;
uniform float dissipation;

void main() {
  vec2 coord = v_uv - dt * texture2D(u_velocity, v_uv).xy;
  gl_FragColor = dissipation * texture2D(u_source, coord);
}
</script>
<script id="fragmentShaderForce" type="x-shader/x-fragment">
precision highp float;
varying vec2 v_uv;
uniform sampler2D u_velocity;
uniform vec2 forcePos;
uniform vec2 force;
uniform float radius;

void main() {
  vec2 coord = v_uv;
  vec2 diff = coord - forcePos;
  float dist = length(diff);
  vec2 velocity = texture2D(u_velocity, coord).xy;
  if(dist < radius) {
    float f = (radius - dist) / radius;
    velocity += force * f;
  }
  gl_FragColor = vec4(velocity, 0.0, 1.0);
}
</script>
<script id="fragmentShaderDivergence" type="x-shader/x-fragment">
precision highp float;
varying vec2 v_uv;
uniform sampler2D u_velocity;
uniform vec2 texelSize;

void main() {
  float left = texture2D(u_velocity, v_uv - vec2(texelSize.x, 0)).x;
  float right = texture2D(u_velocity, v_uv + vec2(texelSize.x, 0)).x;
  float bottom = texture2D(u_velocity, v_uv - vec2(0, texelSize.y)).y;
  float top = texture2D(u_velocity, v_uv + vec2(0, texelSize.y)).y;

  float divergence = 0.5 * (right - left + top - bottom);
  gl_FragColor = vec4(divergence, 0.0, 0.0, 1.0);
}
</script>
<script id="fragmentShaderJacobi" type="x-shader/x-fragment">
precision highp float;
varying vec2 v_uv;
uniform sampler2D u_pressure;
uniform sampler2D u_divergence;
uniform vec2 texelSize;

void main() {
  float left = texture2D(u_pressure, v_uv - vec2(texelSize.x, 0)).x;
  float right = texture2D(u_pressure, v_uv + vec2(texelSize.x, 0)).x;
  float bottom = texture2D(u_pressure, v_uv - vec2(0, texelSize.y)).x;
  float top = texture2D(u_pressure, v_uv + vec2(0, texelSize.y)).x;
  float divergence = texture2D(u_divergence, v_uv).x;

  float pressure = (left + right + bottom + top - divergence) * 0.25;
  gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);
}
</script>
<script id="fragmentShaderGradientSubtract" type="x-shader/x-fragment">
precision highp float;
varying vec2 v_uv;
uniform sampler2D u_velocity;
uniform sampler2D u_pressure;
uniform vec2 texelSize;

void main() {
  float left = texture2D(u_pressure, v_uv - vec2(texelSize.x, 0)).x;
  float right = texture2D(u_pressure, v_uv + vec2(texelSize.x, 0)).x;
  float bottom = texture2D(u_pressure, v_uv - vec2(0, texelSize.y)).x;
  float top = texture2D(u_pressure, v_uv + vec2(0, texelSize.y)).x;

  vec2 velocity = texture2D(u_velocity, v_uv).xy;
  velocity.xy -= vec2(right - left, top - bottom) * 0.5;
  gl_FragColor = vec4(velocity, 0.0, 1.0);
}
</script>
<script id="fragmentShaderDisplay" type="x-shader/x-fragment">
precision highp float;
varying vec2 v_uv;
uniform sampler2D u_velocity;
uniform sampler2D u_pressure;

void main() {
  float pressure = texture2D(u_pressure, v_uv).x;
  vec2 velocity = texture2D(u_velocity, v_uv).xy;

  // Color map for pressure (blue low, red high)
  float p = clamp(pressure * 5.0, -1.0, 1.0);
  vec3 color;
  if(p > 0.0) {
    color = mix(vec3(0.0,0.0,1.0), vec3(1.0,0.0,0.0), p);
  } else {
    color = mix(vec3(0.0,0.0,1.0), vec3(0.0,1.0,1.0), -p);
  }

  gl_FragColor = vec4(color, 1.0);
}
</script>
<script>
(() => {
  // Basic WebGL2 fluid sim setup adapted from Jos Stam style solver
  const canvas = document.getElementById('canvas');
  const gl = canvas.getContext('webgl2');
  if (!gl) {
    alert("WebGL2 is required for this simulation.");
    return;
  }

  const SIM_RES = 256;
  let obstacles = new Uint8Array(SIM_RES * SIM_RES);

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // Compile shader helper
  function compileShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      throw new Error(gl.getShaderInfoLog(shader));
    }
    return shader;
  }

  // Create program helper
  function createProgram(vsSrc, fsSrc) {
    const vs = compileShader(gl.VERTEX_SHADER, vsSrc);
    const fs = compileShader(gl.FRAGMENT_SHADER, fsSrc);
    const program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    if(!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      throw new Error(gl.getProgramInfoLog(program));
    }
    return program;
  }

  // Create a fullscreen quad
  const quadVerts = new Float32Array([
    -1, -1,
    1, -1,
    -1, 1,
    -1, 1,
    1, -1,
    1, 1,
  ]);
  const quadVBO = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
  gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);

  // Create framebuffer and textures helper
  function createFBO(w,h,internalFormat,format,type) {
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);

    const fbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    return {tex, fbo, w, h};
  }

  // Ping-pong helper
  function createDoubleFBO(w,h,internalFormat,format,type) {
    let fbo1 = createFBO(w,h,internalFormat,format,type);
    let fbo2 = createFBO(w,h,internalFormat,format,type);
    return {
      read: fbo1,
      write: fbo2,
      swap() {
        let temp = this.read;
        this.read = this.write;
        this.write = temp;
      }
    };
  }

  // Load shaders
  const vertexShaderSrc = document.getElementById('vertexShader').textContent;
  const advectShaderSrc = document.getElementById('fragmentShaderAdvect').textContent;
  const forceShaderSrc = document.getElementById('fragmentShaderForce').textContent;
  const divergenceShaderSrc = document.getElementById('fragmentShaderDivergence').textContent;
  const jacobiShaderSrc = document.getElementById('fragmentShaderJacobi').textContent;
  const gradientSubtractShaderSrc = document.getElementById('fragmentShaderGradientSubtract').textContent;
  const displayShaderSrc = document.getElementById('fragmentShaderDisplay').textContent;

  // Programs
  const advectProgram = createProgram(vertexShaderSrc, advectShaderSrc);
  const forceProgram = createProgram(vertexShaderSrc, forceShaderSrc);
  const divergenceProgram = createProgram(vertexShaderSrc, divergenceShaderSrc);
  const jacobiProgram = createProgram(vertexShaderSrc, jacobiShaderSrc);
  const gradientSubtractProgram = createProgram(vertexShaderSrc, gradientSubtractShaderSrc);
  const displayProgram = createProgram(vertexShaderSrc, displayShaderSrc);

  // Setup fullscreen quad attribute
  function setupQuad(program) {
    const posLoc = gl.getAttribLocation(program, "a_position");
    gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
  }

  // Create double FBOs for velocity and pressure
  let velocity = createDoubleFBO(SIM_RES, SIM_RES, gl.RG16F, gl.RG, gl.FLOAT);
  let pressure = createDoubleFBO(SIM_RES, SIM_RES, gl.R16F, gl.RED, gl.FLOAT);
  let divergence = createFBO(SIM_RES, SIM_RES, gl.R16F, gl.RED, gl.FLOAT);

  // Initialize velocity and pressure to zero
  gl.bindFramebuffer(gl.FRAMEBUFFER, velocity.read.fbo);
  gl.clearColor(0,0,0,1);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.bindFramebuffer(gl.FRAMEBUFFER, velocity.write.fbo);
  gl.clearColor(0,0,0,1);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.bindFramebuffer(gl.FRAMEBUFFER, pressure.read.fbo);
  gl.clearColor(0,0,0,1);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.bindFramebuffer(gl.FRAMEBUFFER, pressure.write.fbo);
  gl.clearColor(0,0,0,1);
  gl.clear(gl.COLOR_BUFFER_BIT);

  // Simulation parameters
  const dt = 0.016;
  const dissipation = 0.99;
  const numJacobiIterations = 20;

  // Wind force from left -> right (constant)
  function applyWind() {
    gl.useProgram(forceProgram);
    setupQuad(forceProgram);
    gl.uniform1i(gl.getUniformLocation(forceProgram, "u_velocity"), 0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, velocity.read.tex);

    // Apply horizontal force on a vertical band on left side
    const windForcePos = [0.05, 0.5];
    const windForceVec = [2.0, 0.0];
    const radius = 0.1;

    gl.uniform2fv(gl.getUniformLocation(forceProgram, "forcePos"), windForcePos);
    gl.uniform2fv(gl.getUniformLocation(forceProgram, "force"), windForceVec);
    gl.uniform1f(gl.getUniformLocation(forceProgram, "radius"), radius);

    gl.bindFramebuffer(gl.FRAMEBUFFER, velocity.write.fbo);
    gl.viewport(0, 0, SIM_RES, SIM_RES);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    velocity.swap();
  }

  // Advection step
  function advect(field, velocityField) {
    gl.useProgram(advectProgram);
    setupQuad(advectProgram);
    gl.uniform1i(gl.getUniformLocation(advectProgram, "u_velocity"), 0);
    gl.uniform1i(gl.getUniformLocation(advectProgram, "u_source"), 1);
    gl.uniform1f(gl.getUniformLocation(advectProgram, "dt"), dt);
    gl.uniform1f(gl.getUniformLocation(advectProgram, "dissipation"), dissipation);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, velocityField.read.tex);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, field.read.tex);

    gl.bindFramebuffer(gl.FRAMEBUFFER, field.write.fbo);
    gl.viewport(0, 0, SIM_RES, SIM_RES);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    field.swap();
  }

  // Compute divergence
  function computeDivergence(velocityField) {
    gl.useProgram(divergenceProgram);
    setupQuad(divergenceProgram);

    gl.uniform1i(gl.getUniformLocation(divergenceProgram, "u_velocity"), 0);
    gl.uniform2fv(gl.getUniformLocation(divergenceProgram, "texelSize"), [1/SIM_RES,1/SIM_RES]);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, velocityField.read.tex);

    gl.bindFramebuffer(gl.FRAMEBUFFER, divergence.fbo);
    gl.viewport(0, 0, SIM_RES, SIM_RES);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
  }

  // Pressure solve (Jacobi iteration)
  function pressureSolve() {
    gl.useProgram(jacobiProgram);
    setupQuad(jacobiProgram);
    gl.uniform1i(gl.getUniformLocation(jacobiProgram, "u_divergence"), 1);
    gl.uniform2fv(gl.getUniformLocation(jacobiProgram, "texelSize"), [1/SIM_RES, 1/SIM_RES]);

    for(let i = 0; i < numJacobiIterations; i++) {
      gl.uniform1i(gl.getUniformLocation(jacobiProgram, "u_pressure"), 0);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, pressure.read.tex);
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, divergence.tex);

      gl.bindFramebuffer(gl.FRAMEBUFFER, pressure.write.fbo);
      gl.viewport(0, 0, SIM_RES, SIM_RES);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      pressure.swap();
    }
  }

  // Subtract gradient to make velocity divergence free
  function subtractGradient() {
    gl.useProgram(gradientSubtractProgram);
    setupQuad(gradientSubtractProgram);
    gl.uniform1i(gl.getUniformLocation(gradientSubtractProgram, "u_velocity"), 0);
    gl.uniform1i(gl.getUniformLocation(gradientSubtractProgram, "u_pressure"), 1);
    gl.uniform2fv(gl.getUniformLocation(gradientSubtractProgram, "texelSize"), [1/SIM_RES, 1/SIM_RES]);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, velocity.read.tex);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, pressure.read.tex);

    gl.bindFramebuffer(gl.FRAMEBUFFER, velocity.write.fbo);
    gl.viewport(0, 0, SIM_RES, SIM_RES);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    velocity.swap();
  }

  // Draw final pressure and velocity map
  function renderDisplay() {
    gl.useProgram(displayProgram);
    setupQuad(displayProgram);

    gl.uniform1i(gl.getUniformLocation(displayProgram, "u_velocity"), 0);
    gl.uniform1i(gl.getUniformLocation(displayProgram, "u_pressure"), 1);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, velocity.read.tex);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, pressure.read.tex);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
  }

  // Obstacles mask texture setup
  // White = obstacle, black = fluid
  let obstacleTex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, obstacleTex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  function updateObstacleTexture() {
    gl.bindTexture(gl.TEXTURE_2D, obstacleTex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, SIM_RES, SIM_RES, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, obstacles);
  }

  // Initialize empty obstacles
  for(let i = 0; i < obstacles.length; i++) obstacles[i] = 0;
  updateObstacleTexture();

  // Add rectangular obstacles in middle by default
  function addObstacle(x, y, size=12) {
    let centerX = Math.floor(x * SIM_RES);
    let centerY = Math.floor(y * SIM_RES);
    for(let i = -size; i <= size; i++) {
      for(let j = -size; j <= size; j++) {
        let xi = centerX + i;
        let yj = centerY + j;
        if(xi >= 0 && xi < SIM_RES && yj >= 0 && yj < SIM_RES) {
          obstacles[yj * SIM_RES + xi] = 255;
        }
      }
    }
    updateObstacleTexture();
  }

  // Remove obstacle on click (toggle)
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width;
    const y = 1 - (e.clientY - rect.top) / rect.height;
    let cx = Math.floor(x * SIM_RES);
    let cy = Math.floor(y * SIM_RES);
    // Toggle obstacle cell (square 12x12)
    let exists = false;
    for(let i = -12; i <= 12; i++) {
      for(let j = -12; j <= 12; j++) {
        let xi = cx + i;
        let yj = cy + j;
        if(xi >= 0 && xi < SIM_RES && yj >= 0 && yj < SIM_RES) {
          if(obstacles[yj * SIM_RES + xi] === 255) exists = true;
        }
      }
    }
    let newVal = exists ? 0 : 255;
    for(let i = -12; i <= 12; i++) {
      for(let j = -12; j <= 12; j++) {
        let xi = cx + i;
        let yj = cy + j;
        if(xi >= 0 && xi < SIM_RES && yj >= 0 && yj < SIM_RES) {
          obstacles[yj * SIM_RES + xi] = newVal;
        }
      }
    }
    updateObstacleTexture();
  });

  // Main simulation step
  function step() {
    applyWind();
    advect(velocity, velocity);
    computeDivergence(velocity);
    pressureSolve();
    subtractGradient();
  }

  // Resize canvas
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0,0,canvas.width,canvas.height);
  }
  window.addEventListener('resize', resize);
  resize();

  // Run simulation loop
  function loop() {
    step();
    renderDisplay();
    requestAnimationFrame(loop);
  }
  loop();

})();
</script>
</body>
</html>

